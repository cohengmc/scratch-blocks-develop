<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Exercise Playground</title>

    <script src="../blockly_uncompressed_horizontal.js"></script>
    <script src="../msg/messages.js"></script>
    <script src="../blocks_common/math.js"></script>
    <script src="../blocks_common/text.js"></script>
    <script src="../blocks_horizontal/control.js"></script>
    <script src="../blocks_horizontal/event.js"></script>
    <script src="../blocks_horizontal/wedo.js"></script>
    <script src="../blocks_horizontal/default_toolbox.js"></script>
    <script src="../blocks_horizontal/calisthenics_blocks.js"></script>
    <script src="../blocks_horizontal/handstands_blocks.js"></script>
    <script src="../blocks_horizontal/atg_blocks.js"></script>
    <script src="../blocks_horizontal/activities_blocks.js"></script>
    <script src="../blocks_horizontal/weightlifting_blocks.js"></script>
    <script src="../blocks_horizontal/h2t_blocks.js"></script>
    <script src="../core/json.js"></script>
    <script>
      'use strict';

      var fakeDragStack = [];
      var workspace = null;

      function start() {
        var soundsEnabled = true; // Default to enabled

        // Setup blocks
        // Parse the URL arguments.
        var match = location.search.match(/dir=([^&]+)/);
        var rtl = match && match[1] == 'rtl';
        var toolbox = getToolboxElement();

        match = location.search.match(/side=([^&]+)/);
        var side = match ? match[1] : 'start';

        workspace = Blockly.inject('blocklyDiv', {
          comments: false,
          disable: false,
          collapse: false,
          media: '../media/',
          readOnly: false,
          rtl: rtl,
          scrollbars: true,
          toolbox: toolbox,
          trashcan: true,
          horizontalLayout: side == 'top' || side == 'bottom',
          toolboxPosition: side == 'top' || side == 'start' ? 'start' : 'end',
          sounds: soundsEnabled,
          grid: {spacing: 16,
            length: 1,
            colour: '#2C344A',
            snap: false
          },
          zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 4,
            minScale: 0.25,
            scaleSpeed: 1.1
          },
          colours: {
            fieldShadow: 'rgba(255, 255, 255, 0.3)',
            dragShadowOpacity: 0.6
          }
        });
        
      }

      function getToolboxElement() {
        var match = location.search.match(/toolbox=([^&]+)/);
        var toolboxType = match ? match[1] : 'categories';
        
        console.log('Getting toolbox element for type:', toolboxType);
        
        // Get JSON toolbox and convert to XML for Blockly
        var jsonToolbox;
        if (toolboxType === 'categories') {
          jsonToolbox = Blockly.Blocks.defaultToolbox;
        } else if (toolboxType === 'simple') {
          jsonToolbox = Blockly.Blocks.defaultToolboxSimple;
        } else {
          return null;
        }
        
        console.log('Original toolbox:', jsonToolbox);
        
        // Add custom blocks to the toolbox
        addCustomBlocksToToolbox(jsonToolbox);
        
        console.log('Toolbox after adding custom blocks:', jsonToolbox);
        
        // Convert JSON toolbox to XML
        var xmlElement = convertJsonToolboxToXml(jsonToolbox);
        console.log('Converted XML element:', xmlElement);
        
        return xmlElement;
      }

      function convertJsonToolboxToXml(jsonToolbox) {
        var xmlString = '<xml style="display: none">';
        
        if (jsonToolbox.kind === 'categoryToolbox') {
          // Handle category toolbox
          for (var i = 0; i < jsonToolbox.contents.length; i++) {
            var category = jsonToolbox.contents[i];
            xmlString += '<category name="' + category.name + '" id="' + category.id + 
                        '" colour="' + category.colour + '" secondaryColour="' + category.secondaryColour + '">';
            
            for (var j = 0; j < category.contents.length; j++) {
              var block = category.contents[j];
              xmlString += convertJsonBlockToXml(block);
            }
            
            xmlString += '</category>';
          }
        } else if (jsonToolbox.kind === 'flyoutToolbox') {
          // Handle simple flyout toolbox
          for (var i = 0; i < jsonToolbox.contents.length; i++) {
            var block = jsonToolbox.contents[i];
            xmlString += convertJsonBlockToXml(block);
          }
        }
        
        xmlString += '</xml>';
        
        // Parse the XML string and return the DOM element
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(xmlString, 'text/xml');
        return xmlDoc.documentElement;
      }

      function convertJsonBlockToXml(blockJson) {
        var xml = '<block type="' + blockJson.type + '">';
        
        if (blockJson.inputs) {
          for (var inputName in blockJson.inputs) {
            var input = blockJson.inputs[inputName];
            xml += '<value name="' + inputName + '">';
            
            if (input.shadow) {
              xml += '<shadow type="' + input.shadow.type + '">';
              if (input.shadow.fields) {
                for (var fieldName in input.shadow.fields) {
                  xml += '<field name="' + fieldName + '">' + input.shadow.fields[fieldName] + '</field>';
                }
              }
              xml += '</shadow>';
            }
            
            xml += '</value>';
          }
        }
        
        xml += '</block>';
        return xml;
      }

      function toJson() {
        var output = document.getElementById('importExport');
        var json = Blockly.Json.workspaceToJson(workspace);
        output.value = Blockly.Json.workspaceToText(workspace);
        output.focus();
        output.select();
        taChange();
      }

      function fromJson() {
        var input = document.getElementById('importExport');
        try {
          Blockly.Json.textToWorkspace(input.value, workspace);
          taChange();
        } catch (e) {
          console.error('Invalid JSON:', e);
          alert('Invalid JSON format. Please check your input.');
        }
      }

      // Disable the "Import from JSON" button if the JSON is invalid.
      // Preserve text between page reloads.
      function taChange() {
        var textarea = document.getElementById('importExport');
        if (sessionStorage) {
          sessionStorage.setItem('textarea_json', textarea.value);
        }
        var valid = true;
        try {
          JSON.parse(textarea.value);
        } catch (e) {
          valid = false;
        }
        document.getElementById('import').disabled = !valid;
      }

      function logEvents(state) {
        var checkbox = document.getElementById('logCheck');
        checkbox.checked = state;
        if (sessionStorage) {
          sessionStorage.setItem('logEvents', state ? 'checked' : '');
        }
        if (state) {
          workspace.addChangeListener(logger);
        } else {
          workspace.removeChangeListener(logger);
        }
      }

      function logFlyoutEvents(state) {
        var checkbox = document.getElementById('logFlyoutCheck');
        checkbox.checked = state;
        if (sessionStorage) {
          sessionStorage.setItem('logFlyoutEvents', state ? 'checked' : '');
        }
        var flyoutWorkspace = (workspace.flyout_) ? workspace.flyout_.workspace_ :
          workspace.toolbox_.flyout_.workspace_;
        if (state) {
          flyoutWorkspace.addChangeListener(logger);
        } else {
          flyoutWorkspace.removeChangeListener(logger);
        }
      }

      function logger(e) {
        console.log(e);
      }

      function glowBlock() {
        if (Blockly.selected) {
          workspace.glowBlock(Blockly.selected.id, true);
        }
      }

      function unglowBlock() {
        if (Blockly.selected) {
          workspace.glowBlock(Blockly.selected.id, false);
        }
      }

      function glowStack() {
        if (Blockly.selected) {
          workspace.glowStack(Blockly.selected.id, true);
        }
      }

      function unglowStack() {
        if (Blockly.selected) {
          workspace.glowStack(Blockly.selected.id, false);
        }
      }

      function sprinkles(n) {
        var prototypes = [];
        var toolbox = workspace.options.languageTree;
        if (!toolbox) {
          console.error('Toolbox not found; add a toolbox element to the DOM.');
          return;
        }
        
        // Handle JSON toolbox
        var blocks = [];
        if (toolbox.contents) {
          // JSON toolbox
          for (var i = 0; i < toolbox.contents.length; i++) {
            var category = toolbox.contents[i];
            if (category.contents) {
              for (var j = 0; j < category.contents.length; j++) {
                blocks.push(category.contents[j]);
              }
            }
          }
        } else {
          // XML toolbox (fallback)
          blocks = toolbox.getElementsByTagName('block');
        }
        
        for (var i = 0; i < n; i++) {
          var blockDef = blocks[Math.floor(Math.random() * blocks.length)];
          var block;
          
          if (blockDef.type) {
            // JSON block definition
            block = workspace.newBlock(blockDef.type);
          } else {
            // XML block element
            block = Blockly.Xml.domToBlock(blockDef, workspace);
          }
          
          block.initSvg();
          block.moveBy(
            Math.round(Math.random() * 450 + 40),
            Math.round(Math.random() * 600 + 40)
          );
        }
      }

      function spaghetti(n) {
        var xml = spaghettiXml;
        for(var i = 0; i < n; i++) {
          xml = xml.replace(/(<(statement|next)( name="SUBSTACK")?>)<\//g,
          '$1' + spaghettiXml + '</');
        }
        xml = '<xml xmlns="http://www.w3.org/1999/xhtml">' + xml + '</xml>';
        var dom = Blockly.Xml.textToDom(xml);
        console.time('Spaghetti domToWorkspace');
        Blockly.Xml.domToWorkspace(workspace, dom);
        console.timeEnd('Spaghetti domToWorkspace');
      }

      var spaghettiXml = [
        '  <block type="control_repeat">',
        '    <value name="TIMES">',
        '      <shadow type="math_whole_number">',
        '        <field name="NUM">10</field>',
        '      </shadow>',
        '    </value>',
        '    <statement name="SUBSTACK"></statement>',
        '    <next></next>',
        '  </block>'
      ].join('\n');

      function fakeDrag(id, dx, dy, opt_workspace) {
        var ws = opt_workspace || Blockly.getMainWorkspace();
        var blockToDrag = ws.getBlockById(id);

        if (!blockToDrag) {
          fakeDragWrapper();
          return;
        }
        var blockTop = blockToDrag.svgGroup_.getBoundingClientRect().top;
        var blockLeft = blockToDrag.svgGroup_.getBoundingClientRect().left;

        // Click somewhere on the block.
        var mouseDownEvent = new MouseEvent('mousedown',
            {clientX: blockLeft + 5, clientY: blockTop + 5});
        blockToDrag.onMouseDown_(mouseDownEvent);

        // Throw in a move for good measure.
        setTimeout(
          function() {
            var mouseMoveEvent = new MouseEvent('mousemove',
                {clientX: blockLeft + dx,
                clientY: blockTop + dy});
            blockToDrag.onMouseMove_(mouseMoveEvent);

            // Drop at dx, dy.
            setTimeout(
              function() {
                var mouseUpEvent = new MouseEvent('mouseup',
                    {clientX: blockLeft + dx,
                    clientY: blockTop + dy});
                blockToDrag.onMouseUp_(mouseUpEvent);

                setTimeout(fakeDragWrapper(), 100);
              }, 30);
          }, 30);
      };

      function fakeDragWrapper() {
        var dragInfo = fakeDragStack.pop();
        if (dragInfo) {
          fakeDrag(dragInfo.id, dragInfo.dx, dragInfo.dy, dragInfo.workspace);
        }
      }

      function fakeManyDrags() {
        var blockList = workspace.getAllBlocks();
        for (var i = 0; i < 2 * blockList.length; i++) {
          fakeDragStack.push(
            {
              id: blockList[Math.round(Math.random() * (blockList.length - 1))].id,
              // Move some blocks up and to the left, but mostly down and to the right.
              dx: Math.round((Math.random() - 0.25) * 200),
              dy: Math.round((Math.random() - 0.25) * 200),
              workspace: workspace
            });
        }
        fakeDragWrapper();
      }

      // Store custom blocks
      var customBlocks = {};
      var customBlockDefinitions = {};

      function createNewBlock() {
        var blockTypeName = document.getElementById('blockTypeName').value.trim();
        var blockColor = document.getElementById('blockColor').value;
        var blockMessage = document.getElementById('blockMessage').value.trim();
        
        if (!blockTypeName) {
          alert('Please enter a block type name');
          return;
        }
        
        if (!blockMessage) {
          alert('Please enter a block message');
          return;
        }
        
        // Create the JSON definition with hardcoded args
        var jsonDefinition = {
          "id": blockTypeName,
          "message0": "%1 " + blockMessage,
          "args0": [
            {
              "type": "field_image",
              "src": Blockly.mainWorkspace.options.pathToMedia + "icons/exercise_icons/calisthenics/push_up.svg",
              "width": 50,
              "height": 50,
              "alt": "Push Up Exercise"
            },
            {
              "type": "input_value",
              "name": "DURATION",
              "check": "Number"
            }
          ],
          "inputsInline": true,
          "previousStatement": null,
          "nextStatement": null,
          "colour": blockColor,
          "colourSecondary": adjustColorBrightness(blockColor, -20),
          "colourTertiary": adjustColorBrightness(blockColor, -40),
          "colourQuaternary": adjustColorBrightness(blockColor, -60)
        };
        
        // Register the block
        Blockly.Blocks[blockTypeName] = {
          init: function() {
            this.jsonInit(jsonDefinition);
          }
        };
        
        // Store the definition
        customBlockDefinitions[blockTypeName] = jsonDefinition;
        
        alert('Block "' + blockTypeName + '" created successfully!');
        
        // Update export area
        updateCustomBlocksExport();
      }
      
      function adjustColorBrightness(hexColor, percent) {
        // Convert hex to RGB
        var r = parseInt(hexColor.substr(1, 2), 16);
        var g = parseInt(hexColor.substr(3, 2), 16);
        var b = parseInt(hexColor.substr(5, 2), 16);
        
        // Adjust brightness
        r = Math.max(0, Math.min(255, r + (r * percent / 100)));
        g = Math.max(0, Math.min(255, g + (g * percent / 100)));
        b = Math.max(0, Math.min(255, b + (b * percent / 100)));
        
        // Convert back to hex
        return "#" + Math.round(r).toString(16).padStart(2, '0') + 
               Math.round(g).toString(16).padStart(2, '0') + 
               Math.round(b).toString(16).padStart(2, '0');
      }

      function addBlockToToolbox() {
        var blockTypeName = document.getElementById('blockTypeName').value.trim();
        var category = document.getElementById('blockCategory').value;
        
        if (!blockTypeName) {
          alert('Please enter a block type name');
          return;
        }
        
        if (!customBlockDefinitions[blockTypeName]) {
          alert('Please create the block first');
          return;
        }
        
        // Add to custom blocks storage
        if (!customBlocks[category]) {
          customBlocks[category] = [];
        }
        
        // Check if block already exists in this category
        var exists = customBlocks[category].some(function(block) {
          return block.type === blockTypeName;
        });
        
        if (exists) {
          alert('Block already exists in this category');
          return;
        }
        
        // Add block to category
        var blockEntry = {
          "kind": "block",
          "type": blockTypeName
        };
        
        // Add inputs for the hardcoded structure
        blockEntry.inputs = {
          "DURATION": {
            "shadow": {
              "type": "math_positive_number",
              "fields": {
                "NUM": "1"
              }
            }
          }
        };
        
        customBlocks[category].push(blockEntry);
        
        console.log('Added block to category:', category);
        console.log('Block entry:', blockEntry);
        console.log('Current custom blocks:', customBlocks);
        
        // Refresh the workspace to update the toolbox
        refreshWorkspace();
        
        alert('Block added to toolbox in category "' + category + '"');
      }

      function getDefaultShadowType(fieldType) {
        switch (fieldType) {
          case 'field_input':
          case 'field_textinput':
            return 'text';
          case 'field_number':
          case 'field_math_number':
          case 'input_value':
            return 'math_number';
          case 'field_dropdown':
            return 'dropdown_generic';
          case 'field_checkbox':
            return 'logic_boolean';
          default:
            return 'math_number';
        }
      }

      function getDefaultFields(fieldType) {
        switch (fieldType) {
          case 'field_input':
          case 'field_textinput':
            return { "TEXT": "" };
          case 'field_number':
          case 'field_math_number':
          case 'input_value':
            return { "NUM": "1" };
          case 'field_checkbox':
            return { "BOOL": "FALSE" };
          default:
            return { "NUM": "1" };
        }
      }

      function refreshWorkspace() {
        // Simple approach: reload the page to refresh the toolbox
        // This ensures all custom blocks are properly loaded
        if (confirm('The toolbox needs to be refreshed to show your new block. Reload the page?')) {
          location.reload();
        }
      }

      function addCustomBlocksToToolbox(jsonToolbox) {
        console.log('Adding custom blocks to toolbox:', customBlocks);
        console.log('Toolbox kind:', jsonToolbox.kind);
        
        if (jsonToolbox.kind === 'categoryToolbox') {
          // Add custom blocks to existing categories
          for (var categoryName in customBlocks) {
            var categoryBlocks = customBlocks[categoryName];
            console.log('Processing category:', categoryName, 'with blocks:', categoryBlocks);
            
            // Find the category in the toolbox
            var category = jsonToolbox.contents.find(function(cat) {
              return cat.id === categoryName;
            });
            
            if (category) {
              console.log('Found existing category:', categoryName);
              // Add blocks to existing category
              category.contents = category.contents.concat(categoryBlocks);
            } else {
              console.log('Creating new category:', categoryName);
              // Create new category
              jsonToolbox.contents.push({
                "kind": "category",
                "name": categoryName.charAt(0).toUpperCase() + categoryName.slice(1),
                "id": categoryName,
                "colour": "#FF6680",
                "secondaryColour": "#FF4D6A",
                "contents": categoryBlocks
              });
            }
          }
        } else if (jsonToolbox.kind === 'flyoutToolbox') {
          // Add custom blocks to simple toolbox
          for (var categoryName in customBlocks) {
            jsonToolbox.contents = jsonToolbox.contents.concat(customBlocks[categoryName]);
          }
        }
        
        console.log('Final toolbox contents:', jsonToolbox.contents);
      }

      function clearCustomBlocks() {
        if (confirm('Are you sure you want to clear all custom blocks?')) {
          customBlocks = {};
          customBlockDefinitions = {};
          
          // Clear the workspace
          workspace.clear();
          
          // Refresh the workspace
          refreshWorkspace();
          
          // Clear the export area
          document.getElementById('customBlocksExport').value = '';
          
          alert('All custom blocks cleared');
        }
      }

      function exportCustomBlocks() {
        var exportData = {
          blocks: customBlockDefinitions,
          toolbox: customBlocks
        };
        
        document.getElementById('customBlocksExport').value = JSON.stringify(exportData, null, 2);
      }

      function importCustomBlocks() {
        var importText = document.getElementById('customBlocksExport').value.trim();
        
        if (!importText) {
          alert('Please enter custom blocks data to import');
          return;
        }
        
        try {
          var importData = JSON.parse(importText);
          
          if (importData.blocks) {
            customBlockDefinitions = importData.blocks;
            
            // Register all imported blocks
            for (var blockType in customBlockDefinitions) {
              var definition = customBlockDefinitions[blockType];
              Blockly.Blocks[blockType] = {
                init: function() {
                  this.jsonInit(definition);
                }
              };
            }
          }
          
          if (importData.toolbox) {
            customBlocks = importData.toolbox;
          }
          
          // Refresh the workspace
          refreshWorkspace();
          
          alert('Custom blocks imported successfully!');
          
        } catch (e) {
          alert('Invalid JSON: ' + e.message);
        }
      }

      function updateCustomBlocksExport() {
        exportCustomBlocks();
      }

      // Load custom blocks from session storage on startup
      if (sessionStorage) {
        var savedCustomBlocks = sessionStorage.getItem('customBlocks');
        var savedCustomBlockDefinitions = sessionStorage.getItem('customBlockDefinitions');
        
        if (savedCustomBlocks) {
          try {
            customBlocks = JSON.parse(savedCustomBlocks);
          } catch (e) {
            console.warn('Failed to load custom blocks from session storage:', e);
          }
        }
        
        if (savedCustomBlockDefinitions) {
          try {
            customBlockDefinitions = JSON.parse(savedCustomBlockDefinitions);
            
            // Register all loaded blocks
            for (var blockType in customBlockDefinitions) {
              var definition = customBlockDefinitions[blockType];
              Blockly.Blocks[blockType] = {
                init: function() {
                  this.jsonInit(definition);
                }
              };
            }
          } catch (e) {
            console.warn('Failed to load custom block definitions from session storage:', e);
          }
        }
      }

      // Save custom blocks to session storage when they change
      function saveCustomBlocksToStorage() {
        if (sessionStorage) {
          sessionStorage.setItem('customBlocks', JSON.stringify(customBlocks));
          sessionStorage.setItem('customBlockDefinitions', JSON.stringify(customBlockDefinitions));
        }
      }

      // Override the original functions to save to storage
      var originalCreateNewBlock = createNewBlock;
      createNewBlock = function() {
        originalCreateNewBlock();
        saveCustomBlocksToStorage();
      };

      var originalAddBlockToToolbox = addBlockToToolbox;
      addBlockToToolbox = function() {
        originalAddBlockToToolbox();
        saveCustomBlocksToStorage();
      };

      var originalClearCustomBlocks = clearCustomBlocks;
      clearCustomBlocks = function() {
        originalClearCustomBlocks();
        saveCustomBlocksToStorage();
      };

      var originalImportCustomBlocks = importCustomBlocks;
      importCustomBlocks = function() {
        originalImportCustomBlocks();
        saveCustomBlocksToStorage();
      };

    </script>

    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      body {
        background-color: #fff;
        font-family: sans-serif;
        overflow-x: hidden;
        overflow-y: auto;
      }

      h1 {
        font-weight: normal;
        font-size: 140%;
        margin-top: 0;
      }

      #blocklyDiv {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 100%;
        z-index: 1;
      }

      #collaborators {
        float: right;
        width: 30px;
        margin-left: 10px;
      }

      #collaborators > img {
        margin-right: 5px;
        height: 30px;
        padding-bottom: 5px;
        width: 30px;
        border-radius: 3px;
      }


    </style>
  </head>

  <body onload="start()">
    <div id="collaborators"></div>
    <div id="blocklyDiv"></div>
  </body>
</html>
